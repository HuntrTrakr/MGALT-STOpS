function [J,plot_vars] = LT_DIR_FSM_2D(member,BOD,CONST,OPT,VAR)
% FORM: [J,plot_vars] = LT_DIR_FSM_2D(member,BOD,CONST,OPT,VAR)
%
% |-----------------------------------------------------------------------
% | NOTES:
% |     -Cost function solver for use with MGALT STOpS
% |
% |     -This is the DIRECT segmented method for representing a low-thrust 
% |     orbital tragectory, taken from Coverstone
% |
% |-----------------------------------------------------------------------
% |
% | INPUTS:
% |     -member             (1,Nvar)    [float]         [unitless]
% |         A single member of a population input into the function
% |     -BOD                (1,1)       [struct]        [unitless]
% |         A struct containing information pertaining to the planetary
% |         bodies. Contains list of bodies, launch windows and ToF, and 
% |         planetary R/V/JD vectors. This struct has dynamic fields and 
% |         will adapt to contain only the necesary information
% |     -CONST              (1,1)       [struct]        [unitless]
% |         A struct containing constants used in the calcs. Contains
% |         values for AU, TU, Sun (rad/mu/rp) and (rad/mu/rp/SOI/per) 
% |         for any bodies used in the optimization scheme. This is a 
% |         dynamic struct and will adapt to contain only the necesary 
% |         information
% |     -OPT                (1,1)       [struct]        [unitless]
% |         A struct containing constants user options. Contains the save 
% |         folder, ToF values, and more structs containing informaiton 
% |         for the island model, cost parameters, weighting parameters, 
% |         and all of the islands used in the optimization process
% |     -VAR                (1,1)       [struct]        [unitless]
% |         A struct containing the variable limits
% |
% |-----------------------------------------------------------------------
% |
% | OUTPUTS:
% |     -J                  (1,1)       [float]         [unitless]
% |     	The cost of this member, denoted as 'f' in other functions
% |     -plot_vars          (1,1)       [struct]     	[unitless]
% |         An object containing a lot of information about the 
% |         optimization parameters including: transfers(t and y ode 
% |         outputs), thrust values, thruster pointing angles, transfer 
% |         starting position, planet start/end locations for each 
% |         transfer, JD of each transfer, and tspans of each transfer
% |
% |-----------------------------------------------------------------------
% |
% | MISC:
% |     -References
% |         G. A. Rauwolf and V. L. Coverstone-Carroll, “Near-Optimal Low-Thrust Orbit Transfers Generated by a Genetic Algorithm,” Journal of Spacecraft and Rockets, vol. 33, pp. 859–862, Nov. 1996.
% |
% |-----------------------------------------------------------------------



%% Setup

% Canonical Units
AU = CONST.AU;                  % [km/AU]
TU = CONST.TU*86400;            % [sec/TU]
mew_sun = CONST.Sun_mu;         % [km^3/s^2]
mew_sc = mew_sun*(TU^2/AU^3);  	% [DU^3/TU^2] Mew for the spacecraft

% Total Cost
J = 0;

% Other
transfers = VAR.transfers;



%% Pre-Allocation

% Orbit Variables
tspan = cell(transfers,1);
tspan_temp = zeros(OPT.thrust.Nseg,2);
JD = zeros(transfers,2);


% Cost function variables
pos_rad_sc_trans = zeros(1,transfers);
pos_ang_sc_trans = zeros(1,transfers);
vel_rad_sc_trans = zeros(1,transfers);
vel_tan_sc_trans = zeros(1,transfers);
transfer_time_sc_trans = zeros(1,transfers);


% JD for the bodies during transfer segments
start = member(1,1);
tof = member(1,end);
JD(1,:) = [start, start+tof];                  % Start and end Julian Day

% tspan for all transfer segments    
t0 = 0;                                                     % Initial time
tstep = ((JD(1,end)-JD(1,1))*86400) / OPT.thrust.Nseg;	% Time of each segment

for i1 = 1:OPT.thrust.Nseg

    tspan_temp(i1,1) = t0;
    tspan_temp(i1,2) = t0+tstep;
    t0 = t0+tstep;

end

tspan{1,1} = tspan_temp/TU;     % TU



%% Initial Conditions               (Only for Departure Body)

% Get R and V for the departure planet at the first JD
[planet_R_dep,planet_V_dep,sc_dep_pos_rad,sc_dep_pos_ang,...
    sc_dep_vel_rad,sc_dep_vel_tan] = MGALT_conditionsInit(...
    JD(1,1),BOD,CONST,OPT,VAR,[1:3]);
sc_dep_mass = OPT.thrust.m0;      % inital mass (kg)

% For the plot variables
planet_departure = [planet_R_dep; planet_V_dep];

% Check to see if any additional dV from launch vehicle
if isfield(OPT.thrust,'launch_dV_rad')
    sc_dep_vel_rad = sc_dep_vel_rad + (OPT.thrust.launch_dV_rad*(TU/AU));
end
if isfield(OPT.thrust,'launch_dV_tan')
    sc_dep_vel_tan = sc_dep_vel_tan + (OPT.thrust.launch_dV_tan*(TU/AU));
end



%% Solve Intermediate Conditions    (Transfers Between)

% Solve between transfers
switch transfers
    
    case {1}        % If there are not any Gravity Assists
        
        % Define the initial state vector
        Y0 = [sc_dep_pos_rad; sc_dep_pos_ang; sc_dep_vel_rad; sc_dep_vel_tan; sc_dep_mass];
        seg_coords(1,:) = Y0';

        % Get the angles
        [~,mem_thrust,mem_phi] = DIR_sepVariables('LT_DIR_FSM_2D',member,1);

        % ODE45 to solve for the orbit with broken chunks
        [ttot, Ytot] = ode45(@LT_DIR_FSM_2D_EOM,...
            tspan{1,1}(1,:),Y0,OPT.ode,CONST,OPT,mew_sc,mem_thrust(1),mem_phi(1));

        % Do the rest of the segments
        for i1 = 2:OPT.thrust.Nseg

            Y0 = Ytot(end,:)';
            seg_coords(i1,:) = Y0;

            [ttot_temp, Ytot_temp] = ode45(@LT_DIR_FSM_2D_EOM,...
                tspan{1,1}(i1,:),Y0,OPT.ode,CONST,OPT,mew_sc,mem_thrust(i1),mem_phi(i1));

            Ytot = [Ytot; Ytot_temp]; %#ok<AGROW>
            ttot = [ttot; ttot_temp]; %#ok<AGROW>

        end

        % End Conditions
        pos_rad_sc_trans        = Ytot(end,1);
        pos_ang_sc_trans        = (Ytot(end,2)/360 - floor(Ytot(end,2)/360))*360;   % Accounts for being larger than 360
        vel_rad_sc_trans        = Ytot(end,3);
        vel_tan_sc_trans        = Ytot(end,4);
        transfer_time_sc_trans  = ttot(end);

        % Append to spacecraft plotting variables
        plot_vars.transfers{1,1} = [ttot,Ytot];
        plot_vars.thrust_switch{1,1} = mem_thrust;   % binary vector for Tswitch
        plot_vars.thrust_phi{1,1} = mem_phi;         % still defined in LVLH coords at this point
        plot_vars.seg_start{1,1} = seg_coords;   % positions coordinates of each segment start
        
    otherwise       % If there are Gravity Assists
        
        errorPathDisplay()
        fprintf(2,'MGALT STOpS doe snot support FSM with more than two planets.\n')
        fprintf(2,'It is recommended to use the FBSM instead.\n\n')
        fprintf(2,'To see how Multiple FSM was implemented in STOpS, check versions before "MGALT Removal of Multiple FSM"\n')
        
end



%% Final Conditions                 (Only for Target Body)

% Get R and V for the target planet at the final JD
[planet_R_tar,planet_V_tar,sc_tar_pos_rad,sc_tar_pos_ang,sc_tar_vel_rad,...
    sc_tar_vel_tan] = MGALT_conditionsFinal(...
    JD(end,:),BOD,CONST,OPT,VAR,[4:6],pos_ang_sc_trans);

% For the plot variables
planet_target = [planet_R_tar; planet_V_tar];



%% Plotting Vars and Difference

% Plotting variables
plot_vars.planetary_conditions = [planet_departure, planet_target];
plot_vars.JD = JD;          % variables necessary to plot the thrust vectors
plot_vars.tspan = tspan;  	% time spans for the orbits

% plotOrbits(plot_vars,'MGALT_DIR_FSM_2D',transfers)



%% Calculating Cost

% Get the total cost function for the population member
J = LT_FSM_costFun(J, ...
    [pos_rad_sc_trans, sc_tar_pos_rad], ...
    [pos_ang_sc_trans, sc_tar_pos_ang], ...
    [vel_rad_sc_trans, sc_tar_vel_rad], ...
    [vel_tan_sc_trans, sc_tar_vel_tan], ...
    transfer_time_sc_trans', ...
    CONST,OPT);



end


