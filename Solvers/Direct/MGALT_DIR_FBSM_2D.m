function [J,plot_vars] = MGALT_DIR_FBSM_2D(member,BOD,CONST,OPT,VAR)
% FORM: [J,plot_vars] = MGALT_DIR_FBSM_2D(member,BOD,CONST,OPT,VAR)
%
% |-----------------------------------------------------------------------
% | NOTES:
% |     -Cost function solver for use with MGALT STOpS
% |
% |     -This is the DIRECT segmented method for representing a low-thrust 
% |     orbital tragectory, taken from Coverstone
% |
% |-----------------------------------------------------------------------
% |
% | INPUTS:
% |     -member             (1,Nvar)    [float]         [unitless]
% |         A single member of a population input into the function
% |     -BOD                (1,1)       [struct]        [unitless]
% |         A struct containing information pertaining to the planetary
% |         bodies. Contains list of bodies, launch windows and ToF, and 
% |         planetary R/V/JD vectors. This struct has dynamic fields and 
% |         will adapt to contain only the necesary information
% |     -CONST              (1,1)       [struct]        [unitless]
% |         A struct containing constants used in the calcs. Contains
% |         values for AU, TU, Sun (rad/mu/rp) and (rad/mu/rp/SOI/per) 
% |         for any bodies used in the optimization scheme. This is a 
% |         dynamic struct and will adapt to contain only the necesary 
% |         information
% |     -OPT                (1,1)       [struct]        [unitless]
% |         A struct containing constants user options. Contains the save 
% |         folder, ToF values, and more structs containing informaiton 
% |         for the island model, cost parameters, weighting parameters, 
% |         and all of the islands used in the optimization process
% |     -VAR                (1,1)       [struct]        [unitless]
% |         A struct containing the variable limits
% |
% |-----------------------------------------------------------------------
% |
% | OUTPUTS:
% |     -J                  (1,1)       [float]         [unitless]
% |     	The cost of this member, denoted as 'f' in other functions
% |     -plot_vars          (1,1)       [struct]     	[unitless]
% |         An object containing a lot of information about the 
% |         optimization parameters including: transfers(t and y ode 
% |         outputs), thrust values, thruster pointing angles, transfer 
% |         starting position, planet start/end locations for each 
% |         transfer, JD of each transfer, and tspans of each transfer
% |
% |-----------------------------------------------------------------------
% |
% | MISC:
% |     -References
% |         G. A. Rauwolf and V. L. Coverstone-Carroll, “Near-Optimal Low-Thrust Orbit Transfers Generated by a Genetic Algorithm,” Journal of Spacecraft and Rockets, vol. 33, pp. 859–862, Nov. 1996.
% |
% |-----------------------------------------------------------------------



%% Setup

% Canonical Units
AU = CONST.AU;                  % [km/AU]
TU = CONST.TU*86400;            % [sec/TU]
mew_sun = CONST.Sun_mu;         % [km^3/s^2]
mew_sc = mew_sun*(TU^2/AU^3);  	% [DU^3/TU^2] Mew for the spacecraft

% Total Cost
J = 0;

% Other
transfers = VAR.transfers;



%% Pre-Allocation

% ODE varaibles
tspan_divider = 400;


% Orbit Variables
tspan_fs = cell(transfers,1);
tspan_bs = cell(transfers,1);
tspan_fs_temp = zeros(OPT.thrust.Nseg/2,tspan_divider);
tspan_bs_temp = zeros(OPT.thrust.Nseg/2,tspan_divider);
JD = zeros(transfers,2);

thrust_fs = zeros(transfers,OPT.thrust.Nseg/2);
phi_fs = zeros(transfers,OPT.thrust.Nseg/2);
thrust_bs = zeros(transfers,OPT.thrust.Nseg/2);
phi_bs = zeros(transfers,OPT.thrust.Nseg/2);


% Cost function variables
pos_rad_sc_fs = zeros(1,transfers);
pos_rad_sc_bs = zeros(1,transfers);
pos_ang_sc_fs = zeros(1,transfers);
pos_ang_sc_bs = zeros(1,transfers);
vel_rad_sc_fs = zeros(1,transfers);
vel_rad_sc_bs = zeros(1,transfers);
vel_tan_sc_fs = zeros(1,transfers);
vel_tan_sc_bs = zeros(1,transfers);
transfer_time_sc_fs = zeros(1,transfers);
transfer_time_sc_bs = zeros(1,transfers);


% Transfer variables
planet_departure = zeros(6,1);
planet_trans = zeros(6,transfers-1);
planet_target = zeros(6,1);



%% Perform Transfer(s)

switch transfers
    
    case {1}        % Going from planet A to B
        
        % JD for the bodies during transfer segments
        JD(1,:) = [member(1), member(1)+member(end)];       % Start and end Julian Day

        % time steps
        tstep = ((JD(1,end) - JD(1,1))*86400) / OPT.thrust.Nseg;
        
        % Forward Time
        t0_fs = 0;                          % Initial time forward
        for i1 = 1:(OPT.thrust.Nseg/2)
            tspan_fs_temp(i1,:) = linspace(t0_fs,t0_fs+tstep,tspan_divider);
            t0_fs = t0_fs+tstep;
        end
        tspan_fs_temp = tspan_fs_temp/TU;
        
        % Backward Time
        t0_bs = tspan_fs_temp(end,end)*TU;  % Initial time backward
        for i2 = 1:(OPT.thrust.Nseg/2)
            tspan_bs_temp(i2,:) = linspace(t0_bs,t0_bs-tstep,tspan_divider);
            t0_bs = t0_bs-tstep;
        end
        tspan_bs_temp = tspan_bs_temp/TU;
        
        % Get time steps
        tspan_fs{1,1} = tspan_fs_temp;       % TU
        tspan_bs{1,1} = tspan_bs_temp;       % TU
        
        % Get the angles
        % Using the FSM parser because single transfer has the same data
        % format
        [~,mem_thrust,mem_phi] = DIR_sepVariables('LT_DIR_FSM_2D',member,1);
        thrust_fs = mem_thrust(1:OPT.thrust.Nseg/2);
        phi_fs = mem_phi(1:OPT.thrust.Nseg/2);
        thrust_bs = mem_thrust((OPT.thrust.Nseg/2)+1:end);
        thrust_bs = fliplr(thrust_bs);
        phi_bs = mem_phi((OPT.thrust.Nseg/2)+1:end);
        phi_bs = fliplr(phi_bs);
        
        
        % ********** BODY CONDITIONS **********
        % Get departure body initial conditions
        [planet_R_dep,planet_V_dep,sc_dep_pos_rad,sc_dep_pos_ang,...
            sc_dep_vel_rad,sc_dep_vel_tan] = MGALT_conditionsInit(...
            JD(1,1),BOD,CONST,OPT,VAR,[1:3]);
        
        % Get target body final conditions
        [planet_R_tar,planet_V_tar,sc_tar_pos_rad,sc_tar_pos_ang,...
            sc_tar_vel_rad,sc_tar_vel_tan] = MGALT_conditionsInit(...
            JD(end,end),BOD,CONST,OPT,VAR,[4:6]);
        
        
        % ********** FORWARD SHOOTING **********
        % Check to see if any additional dV from launch vehicle
        if isfield(OPT.thrust,'launch_dV_rad')
            sc_dep_vel_rad = sc_dep_vel_rad + (OPT.thrust.launch_dV_rad*(TU/AU));
        end
        if isfield(OPT.thrust,'launch_dV_tan')
            sc_dep_vel_tan = sc_dep_vel_tan + (OPT.thrust.launch_dV_tan*(TU/AU));
        end
        
        % Define the state for forward shooting
        mass_fs_Y0 = OPT.thrust.m0;     % inital mass (kg)
        Y0_fs = [sc_dep_pos_rad;sc_dep_pos_ang;sc_dep_vel_rad;sc_dep_vel_tan;...
            mass_fs_Y0];
        seg_coords_fs(1,:) = Y0_fs';
        
        % ODE45 to solve for first forward segment
        [ttot_fs,Ytot_fs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
            tspan_fs{1,1}(1,:),Y0_fs,OPT.ode,CONST,OPT,mew_sc,thrust_fs(1),phi_fs(1));
        
        % ODE45 to solve for the rest of the forward segments
        for i3 = 2:OPT.thrust.Nseg/2
            Y0_fs = Ytot_fs(end,:)';
            seg_coords_fs(i3,:) = Y0_fs;
            
            [ttot_fs_temp,Ytot_fs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                tspan_fs{1,1}(i3,:),Y0_fs,OPT.ode,CONST,OPT,mew_sc,thrust_fs(i3),phi_fs(i3));
            
            Ytot_fs = [Ytot_fs; Ytot_fs_temp];
            ttot_fs = [ttot_fs; ttot_fs_temp];
        end
        
        % End Conditions
        pos_rad_sc_fs        = Ytot_fs(end,1);
        pos_ang_sc_fs        = (Ytot_fs(end,2)/360 - floor(Ytot_fs(end,2)/360))*360;   % Accounts for being larger than 360
        vel_rad_sc_fs        = Ytot_fs(end,3);
        vel_tan_sc_fs        = Ytot_fs(end,4);
        transfer_time_sc_fs  = ttot_fs(end);
        
        
        % ********** BACKWARDS SHOOTING **********
        % Get the mass for the start of backwards shooting
        d_mass = Ytot_fs(end,end);
        for i4 = 1:OPT.thrust.Nseg/2
            % For future work, sc_tar_pos_rad is the radial position. This
            % only comes into play if 'SolarSail_thrust' is being used as
            % the thrust model because it needs to know how far away it is.
            % This is something which will need to be assumed and the EOM's
            % will need to be added. This should be as simple as taking the
            % position of the planet and proping forward.
            [~,d_mass] = ode45(@MGALT_DIR_FBSM_mass_2D_EOM,...
                tspan_bs{1,1}(i4,:),d_mass(end),OPT.ode,CONST,OPT,...
                sc_tar_pos_rad,thrust_bs(i4));
        end
        mass_bs_Y0 = d_mass(end);
        
        % Define the state for backwards shooting
        Y0_bs = [sc_tar_pos_rad;sc_tar_pos_ang;sc_tar_vel_rad;sc_tar_vel_tan;...
            mass_bs_Y0];
        seg_coords_bs(1,:) = Y0_bs';
        
        % ODE45 to solve for first backward segment
        [ttot_bs,Ytot_bs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
            tspan_bs{1,1}(1,:),Y0_bs,OPT.ode,CONST,OPT,mew_sc,thrust_bs(1),phi_bs(1));
        
        % ODE45 to solve for the rest of the backward segments
        for i5 = 2:OPT.thrust.Nseg/2
            Y0_bs = Ytot_bs(end,:)';
            seg_coords_bs(i5,:) = Y0_bs;
            
            [ttot_bs_temp,Ytot_bs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                tspan_bs{1,1}(i3,:),Y0_bs,OPT.ode,CONST,OPT,mew_sc,thrust_bs(i3),phi_bs(i3));
            
            Ytot_bs = [Ytot_bs; Ytot_bs_temp];
            ttot_bs = [ttot_bs; ttot_bs_temp];
        end
        
        % End Conditions
        pos_rad_sc_bs        = Ytot_bs(end,1);
        pos_ang_sc_bs        = (Ytot_bs(end,2)/360 - floor(Ytot_bs(end,2)/360))*360;   % Accounts for being larger than 360
        vel_rad_sc_bs        = Ytot_bs(end,3);
        vel_tan_sc_bs        = Ytot_bs(end,4);
        transfer_time_sc_bs  = ttot_bs(end);
        
        
        % ********** Append to spacecraft plotting variables **********
        planet_departure = [planet_R_dep;planet_V_dep];
        planet_target = [planet_R_tar;planet_V_tar];
        plot_vars.transfers_fs{1,1} = [ttot_fs,Ytot_fs];
        plot_vars.transfers_bs{1,1} = [ttot_bs,Ytot_bs];
        plot_vars.transfers{1,1} = [ttot_fs,Ytot_fs;...
                                    flipud(ttot_bs)+ttot_fs(end),flipud(Ytot_bs)];
        plot_vars.thrust_switch_fs{1,1} = thrust_fs;    % binary vector for Tswitch
        plot_vars.thrust_switch_bs{1,1} = thrust_bs;
        plot_vars.thrust_phi_fs{1,1} = phi_fs;          % still defined in LVLH coords at this point
        plot_vars.thrust_phi_bs{1,1} = phi_bs;
        plot_vars.seg_start_fs{1,1} = seg_coords_fs;    % positions coordinates of each segment start
        plot_vars.seg_start_bs{1,1} = seg_coords_bs;
        
    otherwise       % Going from planet A to N via B, C, D, ...
        
        % Misc
        cost_count = 1;
        
        % How many segments is the transfers broken into
        seg = size(member,2) - (2 + ((transfers-1)*5));	% Disregarding the misc info, how many thrust/angle
        seg = seg/transfers;                          	% Thrust/angler per transfer
        seg = seg/2;                                	% How many segments
        
        % For indexing the positions
        array_bodies = [4:6];
        array_member = [seg*2+3,seg*2+4];
        
        
        % JD for the bodies during transfer segments
        start = member(1);
        tof = member(seg*2+5);
        JD(1,:) = [start, start+tof];
        for i1 = 2:transfers-1
            start = member(((i1-1)*((2*seg)+5))+1);
            tof = member(i1*((2*seg)+5));
            JD(i1,:) = [start, start+tof];
        end
        start = member((end-1)-(2*seg));
        tof = member(end);
        JD(end,:) = [start, start+tof];

        % Time steps
        for i2 = 1:transfers
            
            tstep = ((JD(i2,end) - JD(i2,1))*86400) / OPT.thrust.Nseg;

            % Forward Time
            t0_fs = 0;                          % Initial time forward
            for i3 = 1:(OPT.thrust.Nseg/2)
                tspan_fs_temp(i3,:) = linspace(t0_fs,t0_fs+tstep,tspan_divider);
                t0_fs = t0_fs+tstep;
            end
            tspan_fs_temp = tspan_fs_temp/TU;

            % Backward Time
            t0_bs = tspan_fs_temp(end,end)*TU;  % Initial time backward
            for i4 = 1:(OPT.thrust.Nseg/2)
                tspan_bs_temp(i4,:) = linspace(t0_bs,t0_bs-tstep,tspan_divider);
                t0_bs = t0_bs-tstep;
            end
            tspan_bs_temp = tspan_bs_temp/TU;

            % Get time steps
            tspan_fs{i2,1} = tspan_fs_temp;       % TU
            tspan_bs{i2,1} = tspan_bs_temp;       % TU

        end
        

        % Get the thrust and the angles
        % Flip the backwards ones because prop backwards in time
        mem_thrust = member(2:2:seg*2);
        mem_phi = member(3:2:seg*2+1);
        thrust_fs(1,:) = mem_thrust(1:OPT.thrust.Nseg/2);
        phi_fs(1,:) = mem_phi(1:OPT.thrust.Nseg/2);
        thrust_bs(1,:) = mem_thrust((OPT.thrust.Nseg/2)+1:end);
        thrust_bs(1,:) = fliplr(thrust_bs(1,:));
        phi_bs(1,:) = mem_phi((OPT.thrust.Nseg/2)+1:end);
        phi_bs(1,:) = fliplr(phi_bs(1,:));
        for i5 = 2:transfers-1
            [~,mem_thrust,mem_phi] = DIR_sepVariables('MGALT_DIR_FBSM_2D',member,i5,seg);
            thrust_fs(i5,:) = mem_thrust(1:OPT.thrust.Nseg/2);
            phi_fs(i5,:) = mem_phi(1:OPT.thrust.Nseg/2);
            thrust_bs(i5,:) = mem_thrust((OPT.thrust.Nseg/2)+1:end);
            thrust_bs(i5,:) = fliplr(thrust_bs(i5,:));
            phi_bs(i5,:) = mem_phi((OPT.thrust.Nseg/2)+1:end);
            phi_bs(i5,:) = fliplr(phi_bs(i5,:));
        end
        mem_thrust = member(end-(2*seg) : 2 : end-2);
        mem_phi = member((end+1)-(2*seg) : 2 : end-1);
        thrust_fs(end,:) = mem_thrust(1:OPT.thrust.Nseg/2);
        phi_fs(end,:) = mem_phi(1:OPT.thrust.Nseg/2);
        thrust_bs(end,:) = mem_thrust((OPT.thrust.Nseg/2)+1:end);
        thrust_bs(end,:) = fliplr(thrust_bs(end,:));
        phi_bs(end,:) = mem_phi((OPT.thrust.Nseg/2)+1:end);
        phi_bs(end,:) = fliplr(phi_bs(end,:));
        clear mem_thrust mem_phi
        
        
        %% ********** DEPARTURE -> TRANSFER 1 **********
        
        % Departure body initial conditions
        [planet_R_dep,planet_V_dep,sc_dep_pos_rad,sc_dep_pos_ang,...
            sc_dep_vel_rad,sc_dep_vel_tan] = MGALT_conditionsInit(...
            JD(1,1),BOD,CONST,OPT,VAR,[1:3]);
        mass_fs_Y0 = OPT.thrust.m0;     % inital mass (kg)
        
        % Check to see if any additional dV from launch vehicle
        if isfield(OPT.thrust,'launch_dV_rad')
            sc_dep_vel_rad = sc_dep_vel_rad + (OPT.thrust.launch_dV_rad*(TU/AU));
        end
        if isfield(OPT.thrust,'launch_dV_tan')
            sc_dep_vel_tan = sc_dep_vel_tan + (OPT.thrust.launch_dV_tan*(TU/AU));
        end
        
        Y0_fs = [sc_dep_pos_rad;sc_dep_pos_ang;sc_dep_vel_rad;sc_dep_vel_tan;...
            mass_fs_Y0];
        seg_coords_fs(1,:) = Y0_fs';
        
        % ODE45 to solve for first forward segment
        [ttot_fs,Ytot_fs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
            tspan_fs{1,1}(1,:),Y0_fs,OPT.ode,CONST,OPT,mew_sc,thrust_fs(1,1),phi_fs(1,1));
        
        % ODE45 to solve for the rest of the forward segments
        for i6 = 2:OPT.thrust.Nseg/2
            Y0_fs = Ytot_fs(end,:)';
            seg_coords_fs(i6,:) = Y0_fs;
            
            [ttot_fs_temp,Ytot_fs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                tspan_fs{1,1}(i6,:),Y0_fs,OPT.ode,CONST,OPT,mew_sc,thrust_fs(1,i6),phi_fs(1,i6));
            
            Ytot_fs = [Ytot_fs; Ytot_fs_temp];
            ttot_fs = [ttot_fs; ttot_fs_temp];
        end       
        
        % FS end Conditions
        pos_rad_sc_fs(cost_count)    	= Ytot_fs(end,1);
        pos_ang_sc_fs(cost_count)    	= (Ytot_fs(end,2)/360 - floor(Ytot_fs(end,2)/360))*360;   % Accounts for being larger than 360
        vel_rad_sc_fs(cost_count)   	= Ytot_fs(end,3);
        vel_tan_sc_fs(cost_count)       = Ytot_fs(end,4);
        mass_sc_fs_end(cost_count)      = Ytot_fs(end,5);
        transfer_time_sc_fs(cost_count)	= ttot_fs(end);
        
        
        % For the backwards shooting, we need to know what the mass of the
        % spacecraft is. Because some portions of the thrust can be on or
        % off, or variable, a constant mass loss cannot be assumed for the
        % transfer. To find what the mass is, we need to first find the
        % planet position for the first transfer body. The spacecraft is
        % assumed to leave from the center of the body. We can then take
        % this position and put it into an ode to get the mass of the s/c
        % upon arrival at the transfer body. Then this mass can be
        % propogated backwards for the patch point.
        
        % Assume leaving from the center of the planet
        [loc_planet_r,~] = MGALT_stateBodies(JD(1,2),BOD,CONST,OPT,VAR,array_bodies);
        sc_location = loc_planet_r*(1/AU);      % DU     
               
        
        % Get the mass for the start of backwards shooting
        d_mass = Ytot_fs(end,end);      % Mass after first patch point
        for i7 = 1:OPT.thrust.Nseg/2
            % For future work, sc_tar_pos_rad is the radial position. This
            % only comes into play if 'SolarSail_thrust' is being used as
            % the thrust model because it needs to know how far away it is.
            % This is something which will need to be assumed and the EOM's
            % will need to be added. This should be as simple as taking the
            % position of the planet and proping forward.
            [~,d_mass] = ode45(@MGALT_DIR_FBSM_mass_2D_EOM,...
                tspan_bs{1,1}(i7,:),d_mass(end),OPT.ode,CONST,OPT,...
                norm(sc_location),thrust_bs(1,i7));
        end
        mass_bs_Y0 = d_mass(end);
        

        % Get transfer body position and s/c positions
        [planet_R_trans,planet_V_trans,sc_trans_pos_rad,sc_trans_pos_ang,...
            sc_trans_vel_rad,sc_trans_vel_tan,control,sc_vel_helio_enter] = ...
            MGALT_conditionsTransFBSM(...
            JD(1,2),...
            BOD,...
            CONST,...
            OPT,...
            VAR,...
            [tspan_fs{1,1}(1,1),2*tspan_fs{1,1}(end,end)],...
            d_mass(end),...
            [thrust_fs(1,:),thrust_bs(1,:)],...
            [member(array_member),OPT.weighting.control_v],...
            sc_dep_pos_rad,...
            array_bodies);

        % Change the control numbers
        member(array_member) = control(1:2);
        
        % Define the state varaibles for backwards shooting
        Y0_bs = [sc_trans_pos_rad;sc_trans_pos_ang;sc_trans_vel_rad;sc_trans_vel_tan;...
            mass_bs_Y0];
        seg_coords_bs(1,:) = Y0_fs';
        
        % ODE45 to solve for first backward segment
        [ttot_bs,Ytot_bs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
            tspan_bs{1,1}(1,:),Y0_bs,OPT.ode,CONST,OPT,mew_sc,thrust_bs(1,1),phi_bs(1,1));
        
        % ODE45 to solve for the rest of the backward segments
        for i8 = 2:OPT.thrust.Nseg/2
            Y0_bs = Ytot_bs(end,:)';
            seg_coords_bs(i8,:) = Y0_bs;
            
            [ttot_bs_temp,Ytot_bs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                tspan_bs{1,1}(i8,:),Y0_bs,OPT.ode,CONST,OPT,mew_sc,thrust_bs(1,i8),phi_bs(1,i8));
            
            Ytot_bs = [Ytot_bs; Ytot_bs_temp];
            ttot_bs = [ttot_bs; ttot_bs_temp];
        end
        
        
        % BS end Conditions
        pos_rad_sc_bs(cost_count)    	= Ytot_bs(end,1);
        pos_ang_sc_bs(cost_count)    	= (Ytot_bs(end,2)/360 - floor(Ytot_bs(end,2)/360))*360;   % Accounts for being larger than 360
        vel_rad_sc_bs(cost_count)   	= Ytot_bs(end,3);
        vel_tan_sc_bs(cost_count)       = Ytot_bs(end,4);
        mass_sc_bs_end(cost_count)      = Ytot_bs(end,5);
        transfer_time_sc_bs(cost_count)	= ttot_bs(end);
        
        
        % Count up the array bodies
        array_bodies = array_bodies+3;
        array_member = [2*((2*seg)+5)-2,2*((2*seg)+5)-1];   % Have the 2 because starting 2nd transfer
        cost_count = cost_count+1;
        
        
        % Append to spacecraft plotting variables
        planet_departure = [planet_R_dep;planet_V_dep];
        planet_trans(:,1) = [planet_R_trans;planet_V_trans];
        plot_vars.transfers_fs{1,1} = [ttot_fs,Ytot_fs];
        plot_vars.transfers_bs{1,1} = [ttot_bs,Ytot_bs];
        plot_vars.transfers{1,1} = [ttot_fs,Ytot_fs;...
                                    flipud(ttot_bs)+ttot_fs(end),flipud(Ytot_bs)];
        plot_vars.thrust_switch_fs{1,1} = thrust_fs(1,:);    % binary vector for Tswitch
        plot_vars.thrust_switch_bs{1,1} = thrust_bs(1,:);
        plot_vars.thrust_phi_fs{1,1} = phi_fs(1,:);          % still defined in LVLH coords at this point
        plot_vars.thrust_phi_bs{1,1} = phi_bs(1,:);
        plot_vars.seg_start_fs{1,1} = seg_coords_fs;    % positions coordinates of each segment start
        plot_vars.seg_start_bs{1,1} = seg_coords_bs;
        
        
        %%  ********** TRANSFER 1 -> TRANSFER n **********
        
        for i9 = 2:(transfers-1)
            
            % Calculate the FS departure position and vel
            rp_coe = member((i9-1)*((2*seg)+5)-3);        % Number between 0 and 1 for flyby altitude
            
            % Get the gravity assist conditions
            [sc_vel_helio_exit,~] = MGALT_conditionsGravityAssist(BOD,CONST,...
                planet_R_trans,planet_V_trans,sc_vel_helio_enter,rp_coe,i9);
            
            % Convert flyby LVLH
            [~,sc_dep_vel,~] = MGALT_convertHelioLVLH(...
                CONST,planet_R_trans,sc_vel_helio_exit);
            
            % Define the state variables for forward shooting
            mass_fs_Y0 = mass_bs_Y0;     % inital mass (kg)
            Y0_fs = [sc_trans_pos_rad;sc_trans_pos_ang;sc_dep_vel(1);sc_dep_vel(2);...
                mass_fs_Y0];
            seg_coords_fs(1,:) = Y0_fs';
            
            % ODE45 to solve for first forward segment
            [ttot_fs,Ytot_fs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                tspan_fs{i9,1}(1,:),Y0_fs,OPT.ode,CONST,OPT,mew_sc,thrust_fs(i9,1),phi_fs(i9,1));
            
            % ODE45 to solve for the rest of the forward segments
            for i10 = 2:OPT.thrust.Nseg/2
                Y0_fs = Ytot_fs(end,:)';
                seg_coords_fs(i10,:) = Y0_fs;

                [ttot_fs_temp,Ytot_fs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                    tspan_fs{i9,1}(i10,:),Y0_fs,OPT.ode,CONST,OPT,mew_sc,thrust_fs(i9,i10),phi_fs(i9,i10));

                Ytot_fs = [Ytot_fs; Ytot_fs_temp];
                ttot_fs = [ttot_fs; ttot_fs_temp];
            end
            
            % FS end Conditions
            pos_rad_sc_fs(cost_count)    	= Ytot_fs(end,1);
            pos_ang_sc_fs(cost_count)    	= (Ytot_fs(end,2)/360 - floor(Ytot_fs(end,2)/360))*360;   % Accounts for being larger than 360
            vel_rad_sc_fs(cost_count)   	= Ytot_fs(end,3);
            vel_tan_sc_fs(cost_count)       = Ytot_fs(end,4);
            mass_sc_fs_end(cost_count)      = Ytot_fs(end,5);
            transfer_time_sc_fs(cost_count)	= ttot_fs(end);
            
            
            % For the backwards shooting, we need to know what the mass of the
            % spacecraft is. Because some portions of the thrust can be on or
            % off, or variable, a constant mass loss cannot be assumed for the
            % transfer. To find what the mass is, we need to first find the
            % planet position for the first transfer body. The spacecraft is
            % assumed to leave from the center of the body. We can then take
            % this position and put it into an ode to get the mass of the s/c
            % upon arrival at the transfer body. Then this mass can be
            % propogated backwards for the patch point.

            % Assume leaving from the center of the planet
            [loc_planet_r,~] = MGALT_stateBodies(JD(i9,2),BOD,CONST,OPT,VAR,array_bodies);
            sc_location = loc_planet_r*(1/AU);      % DU  
            
            % Get the mass for the start of backwards shooting
            d_mass = Ytot_fs(end,end);      % Mass after first patch point
            for i11 = 1:OPT.thrust.Nseg/2
                % For future work, sc_tar_pos_rad is the radial position. This
                % only comes into play if 'SolarSail_thrust' is being used as
                % the thrust model because it needs to know how far away it is.
                % This is something which will need to be assumed and the EOM's
                % will need to be added. This should be as simple as taking the
                % position of the planet and proping forward.
                [~,d_mass] = ode45(@MGALT_DIR_FBSM_mass_2D_EOM,...
                    tspan_bs{i9,1}(i11,:),d_mass(end),OPT.ode,CONST,OPT,...
                    norm(sc_location),thrust_bs(i9,i11));
            end
            mass_bs_Y0 = d_mass(end);

            % Get transfer body position and s/c positions
            [planet_R_trans,planet_V_trans,sc_trans_pos_rad,sc_trans_pos_ang,...
                sc_trans_vel_rad,sc_trans_vel_tan,control,sc_vel_helio_enter] = ...
                MGALT_conditionsTransFBSM(...
                JD(i9,2),...
                BOD,...
                CONST,...
                OPT,...
                VAR,...
                [tspan_fs{i9,1}(1,1),2*tspan_fs{i9,1}(end,end)],...
                d_mass(end),...
                [thrust_fs(i9,:),thrust_bs(i9,:)],...
                [member(array_member),OPT.weighting.control_v],...
                sc_trans_pos_rad,...
                array_bodies);            

            % Change the control numbers
            member(array_member) = control(1:2);

            % Define the state varaibles for backwards shooting
            Y0_bs = [sc_trans_pos_rad;sc_trans_pos_ang;sc_trans_vel_rad;sc_trans_vel_tan;...
                mass_bs_Y0];
            seg_coords_bs(1,:) = Y0_bs';


            % ODE45 to solve for first backward segment
            [ttot_bs,Ytot_bs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                tspan_bs{i9,1}(1,:),Y0_bs,OPT.ode,CONST,OPT,mew_sc,thrust_bs(i9,1),phi_bs(i9,1));

            % ODE45 to solve for the rest of the backward segments
            for i12 = 2:OPT.thrust.Nseg/2
                Y0_bs = Ytot_bs(end,:)';
                seg_coords_bs(i12,:) = Y0_bs;

                [ttot_bs_temp,Ytot_bs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                    tspan_bs{i9,1}(i12,:),Y0_bs,OPT.ode,CONST,OPT,mew_sc,thrust_bs(i9,i12),phi_bs(i9,i12));

                Ytot_bs = [Ytot_bs; Ytot_bs_temp];
                ttot_bs = [ttot_bs; ttot_bs_temp];
            end

            % BS end Conditions
            pos_rad_sc_bs(cost_count)    	= Ytot_bs(end,1);
            pos_ang_sc_bs(cost_count)    	= (Ytot_bs(end,2)/360 - floor(Ytot_bs(end,2)/360))*360;   % Accounts for being larger than 360
            vel_rad_sc_bs(cost_count)   	= Ytot_bs(end,3);
            vel_tan_sc_bs(cost_count)       = Ytot_bs(end,4);
            mass_sc_bs_end(cost_count)      = Ytot_bs(end,5);
            transfer_time_sc_bs(cost_count)	= ttot_bs(end);

            % Count up the array bodies
            array_bodies = array_bodies+3;
            array_member = [(i9+1)*((2*seg)+5)-2,(i9+1)*((2*seg)+5)-1];   % Have the 2 because starting 2nd transfer
            cost_count = cost_count+1;
            
            
            % Append to spacecraft plotting variables
            planet_trans(:,i9) = [planet_R_trans;planet_V_trans];
            plot_vars.transfers_fs{i9,1} = [ttot_fs,Ytot_fs];
            plot_vars.transfers_bs{i9,1} = [ttot_bs,Ytot_bs];
            plot_vars.transfers{i9,1} = [ttot_fs,Ytot_fs;...
                                        flipud(ttot_bs)+ttot_fs(end),flipud(Ytot_bs)];
            plot_vars.thrust_switch_fs{i9,1} = thrust_fs(i9,:);    % binary vector for Tswitch
            plot_vars.thrust_switch_bs{i9,1} = thrust_bs(i9,:);
            plot_vars.thrust_phi_fs{i9,1} = phi_fs(i9,:);          % still defined in LVLH coords at this point
            plot_vars.thrust_phi_bs{i9,1} = phi_bs(i9,:);
            plot_vars.seg_start_fs{i9,1} = seg_coords_fs;    % positions coordinates of each segment start
            plot_vars.seg_start_bs{i9,1} = seg_coords_bs;

        end
        
        
        %% ********** TRANSFER n -> TARGET **********
        
        % Calculate the FS departure position and vel
        rp_coe = member((end-5)-(2*seg));        % Number between 0 and 1 for flyby altitude
        
        % Get the gravity assist conditions
        [sc_vel_helio_exit,~] = MGALT_conditionsGravityAssist(BOD,CONST,...
            planet_R_trans,planet_V_trans,sc_vel_helio_enter,rp_coe,(size(BOD.bodies,2)-1));
            
        % Convert flyby LVLH
        [~,sc_dep_vel,~] = MGALT_convertHelioLVLH(...
            CONST,planet_R_trans,sc_vel_helio_exit);

        % Define the state variables for forward shooting
        mass_fs_Y0 = mass_bs_Y0;     % inital mass (kg)
        Y0_fs = [sc_trans_pos_rad;sc_trans_pos_ang;sc_dep_vel(1);sc_dep_vel(2);...
            mass_fs_Y0];
        seg_coords_fs(1,:) = Y0_fs';

        % ODE45 to solve for first forward segment
        [ttot_fs,Ytot_fs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
            tspan_fs{end,1}(1,:),Y0_fs,OPT.ode,CONST,OPT,mew_sc,thrust_fs(end,1),phi_fs(end,1));

        % ODE45 to solve for the rest of the forward segments
        for i13 = 2:OPT.thrust.Nseg/2
            Y0_fs = Ytot_fs(end,:)';
            seg_coords_fs(i13,:) = Y0_fs;
            [ttot_fs_temp,Ytot_fs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                tspan_fs{end,1}(i13,:),Y0_fs,OPT.ode,CONST,OPT,mew_sc,thrust_fs(end,i13),phi_fs(end,i13));

            Ytot_fs = [Ytot_fs; Ytot_fs_temp];
            ttot_fs = [ttot_fs; ttot_fs_temp];
        end

        % FS end Conditions
        pos_rad_sc_fs(cost_count)    	= Ytot_fs(end,1);
        pos_ang_sc_fs(cost_count)    	= (Ytot_fs(end,2)/360 - floor(Ytot_fs(end,2)/360))*360;   % Accounts for being larger than 360
        vel_rad_sc_fs(cost_count)   	= Ytot_fs(end,3);
        vel_tan_sc_fs(cost_count)       = Ytot_fs(end,4);
        mass_sc_fs_end(cost_count)      = Ytot_fs(end,5);
        transfer_time_sc_fs(cost_count)	= ttot_fs(end);
        
        
        % Get target body final conditions
        [planet_R_tar,planet_V_tar,sc_tar_pos_rad,sc_tar_pos_ang,...
            sc_tar_vel_rad,sc_tar_vel_tan] = MGALT_conditionsInit(...
            JD(end,end),BOD,CONST,OPT,VAR,array_bodies);
        
         % Get the mass for the start of backwards shooting
        d_mass = Ytot_fs(end,end);      % Mass after first patch point
        for i14 = 1:OPT.thrust.Nseg/2
            % For future work, sc_tar_pos_rad is the radial position. This
            % only comes into play if 'SolarSail_thrust' is being used as
            % the thrust model because it needs to know how far away it is.
            % This is something which will need to be assumed and the EOM's
            % will need to be added. This should be as simple as taking the
            % position of the planet and proping forward.
            [~,d_mass] = ode45(@MGALT_DIR_FBSM_mass_2D_EOM,...
                tspan_bs{end,1}(i14,:),d_mass(end),OPT.ode,CONST,OPT,...
                sc_tar_pos_rad,thrust_bs(end,i14));
        end
        mass_bs_Y0 = d_mass(end);
        
        
        % Define the state for backwards shooting
        Y0_bs = [sc_tar_pos_rad;sc_tar_pos_ang;sc_tar_vel_rad;sc_tar_vel_tan;...
            mass_bs_Y0];
        seg_coords_bs(1,:) = Y0_bs';
        
        % ODE45 to solve for first backward segment
        [ttot_bs,Ytot_bs] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
            tspan_bs{end,1}(1,:),Y0_bs,OPT.ode,CONST,OPT,mew_sc,thrust_bs(end,1),phi_bs(end,1));
        
        % ODE45 to solve for the rest of the backward segments
        for i15 = 2:OPT.thrust.Nseg/2
            Y0_bs = Ytot_bs(end,:)';
            seg_coords_bs(i15,:) = Y0_bs;
            
            [ttot_bs_temp,Ytot_bs_temp] = ode45(@MGALT_DIR_FBSM_2D_EOM,...
                tspan_bs{end,1}(i15,:),Y0_bs,OPT.ode,CONST,OPT,mew_sc,thrust_bs(end,i15),phi_bs(end,i15));
            
            Ytot_bs = [Ytot_bs; Ytot_bs_temp];
            ttot_bs = [ttot_bs; ttot_bs_temp];
        end
        
        % End Conditions
        pos_rad_sc_bs(end)        = Ytot_bs(end,1);
        pos_ang_sc_bs(end)        = (Ytot_bs(end,2)/360 - floor(Ytot_bs(end,2)/360))*360;   % Accounts for being larger than 360
        vel_rad_sc_bs(end)        = Ytot_bs(end,3);
        vel_tan_sc_bs(end)        = Ytot_bs(end,4);
        transfer_time_sc_bs(end)  = ttot_bs(end);
        
        % Append to spacecraft plotting variables
        planet_target = [planet_R_tar;planet_V_tar];
        plot_vars.transfers_fs{end+1,1} = [ttot_fs,Ytot_fs];
        plot_vars.transfers_bs{end+1,1} = [ttot_bs,Ytot_bs];
        plot_vars.transfers{end+11,1} = [ttot_fs,Ytot_fs;...
                                    flipud(ttot_bs)+ttot_fs(end),flipud(Ytot_bs)];
        plot_vars.thrust_switch_fs{end+1,1} = thrust_fs(end,:);    % binary vector for Tswitch
        plot_vars.thrust_switch_bs{end+1,1} = thrust_bs(end,:);
        plot_vars.thrust_phi_fs{end+1,1} = phi_fs(end,:);          % still defined in LVLH coords at this point
        plot_vars.thrust_phi_bs{end+1,1} = phi_bs(end,:);
        plot_vars.seg_start_fs{end+1,1} = seg_coords_fs;    % positions coordinates of each segment start
        plot_vars.seg_start_bs{end+1,1} = seg_coords_bs;
        
        
end



%% Plotting Vars and Difference

% Plotting variables
plot_vars.planetary_conditions = [planet_departure, planet_trans, planet_target];
plot_vars.JD = JD;          % variables necessary to plot the thrust vectors
plot_vars.tspan_fs = tspan_fs;  	% time spans for the orbits
plot_vars.tspan_bs = tspan_bs;

% plotOrbits(plot_vars,'MGALT_DIR_FBSMseg_2D',transfers)



%% Calculating Cost

% Get the total cost function for the population member
J = MGALT_FBSM_costFun(J, ...
    [pos_rad_sc_fs', pos_rad_sc_bs'], ...
    [pos_ang_sc_fs', pos_ang_sc_bs'], ...
    [vel_rad_sc_fs', vel_rad_sc_bs'], ...
    [vel_tan_sc_fs', vel_tan_sc_bs'], ...
    [transfer_time_sc_fs', transfer_time_sc_bs'],...
    CONST,OPT,VAR);



end


